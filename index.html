<!DOCTYPE html>
<html>
<head>
<meta charset=UTF-8>
<title>A Gentle Introduction to the ECMAScript Internationalisation API</title>
<style>
aside{
	display: block;
	float: right;
	width: 50%;
	border: thin solid grey;
	padding: .5em;
}

aside h1{
	font-size: 1em;
}

.canuse{
	background-color: green; 
}

.canuse:after{
	content: &#x2713;
}

</style>
<script>
window.addEventListener("DOMContentLoaded", 
	function isi18nSupported(){
		var canIuse = document.querySelector("#caniuse");
		if(window['Intl'] !== undefined){
			canIuse.innerHTML = "we just checked, and your browser supports the API. Zing!" 
		}
	}
)
</script>

</head>

<body>
<article>
<h1>Using the ECMAScript Internationalisation API</h1>

<p>The new <cite>ECMAScript Internationalization API</cite> (or <abbr title="ECMAScript Internationalization API">i18n API</abbr> for short) helps you automagically localise the output of dates, numbers, currencies  in Javascript. </p>
<p>This short intro  gives you a quick overview of some of the awesome things you will be able to do once the API becomes more widely supported in browsers and in other ECMAScript-based programming environments - like Node.js. </p>
<p>Lets be clear before we start: the  <abbr title="ECMAScript Internationalization API">i18n API</abbr> is not a full internationalization framework, so obviously it won't translate your whole application to another language, but can be really useful for common localisation tasks involving dates, numbers, and currencies.</p>
<h2>Can I use? </h2>
<p>If you want to follow along, please read this section! </p>
<p><strong>The short:</strong> you can follow along but you need Chrome 21 (stable) or above, and our custom i18n monkey-patch. It's already loaded as part of this document, so if you do &quot;inspect element&quot; and bring up your browsers console, you are already good to go! </p>
<p>Before we can actually use the <cite>i18n API</cite>, we need to check if the browser supports it: <span id="caniuse">sadly, your browser is not supported yet.</span> This can be tricky, because, to date, the API is behind a unique verndor prefix (<code>v8</code>) and also &quot;supersedes&quot; existing Javascript functionality. At the time of writing, only partial support exists in Chrome 21 and above - and Chrome Canary 23 seems to have introduced some  bugs that make the API unreliable. </p>
<p>Anyway, the <cite>i18n API</cite> defines the <code>Intl</code> object that should live in the browser's <code>window</code> object. This object is used to contain a bunch of useful other objects that we will make use of in this tutorial: </p>
<pre>if(&quot;Intl&quot; in window){
   //It's supported, lets localize!
}else if(&quot;v8Int&quot; in window){
   //check for V8 implementation
   window.Intl = v8Intl; 
}</pre>
<p>Generally speaking, that would normally would be all you need to go. However, because of the experimental nature of this API, the Chrome team have only patially implemented the API (they have not implemented functionality that overrides existing functionality). Thankfully, it is easy to &quot;monkey-patch&quot;' with a simple script.</p>
<h2>Simple date localisation</h2>
<p> 
  You've probably done this a hundred times:
</p>
<pre>var date = new Date();  </pre>

<p>And possibly displayed it in the browser's default locale by calling:</p>
<pre>date.toLocaleDateString(); 
//returns e.g. &quot;Friday, August 24, 2012&quot; 
</pre>
<h3>The problem</h3>

<p> The above might be all well and good if the user is sitting at home, but what happens if the user is on a PC whose language settings are set to English, but her preferred language is Portuguese as used in Portugal? Lets say our user is backpacking and has logged into your Web application from an internet cafe.</p>
<h3>The solution</h3>
  <aside>
  <h1>Language Tag Trivia</h1>
  <p>A language tag, or more genenerally, they concept of a <dfn>locale</dfn>, doesn't just relate to a languages: it also dictate how dates, times, and currencies are formatted (and even how they are spoken by text-to-speech software!). </p>
  <p>An example you have probably encountered before: 31st of January in the United States is written in short form as: 1/31/2012… while in Australia and the UK it is 31/1/2012 (i.e., days and months are swapped). Many a databases have broken thanks to this :) </p></aside>
<p>Firstly, what we need is to convert what we know about the user's locale  to a <dfn>language tag: </dfn>  a simple string made up of the user's langauge and, optionally, where they are (or would like to pretend they are for the purposes of communication).</p>
<p>You undoubtedly have encountered language tags before. for example 
  &quot;en-US&quot;, … which roughly translates to &quot;English as used in the US&quot;… as opposed to, say, &quot;en-AU&quot;, which would be English as used in Australia. </p>
<h3>Getting the user's locale</h3>
<p>Unfortunately, there is no 100% reliable way in the browser of getting this information unless you ask the user explicitly. There are some hacks, like querying  <code>navigator.language</code> in Chrome and Firefox, or <code>navigator.browserLanguage</code> in IE, or looking at the HTTP <code>Accept-Language</code> header using XHR. </p>
<p>But the above techniques, would not help our previously described backpacking-user: because she is using a computer at an internet cafe, she has no control over the language preferences of the machine. </p>
<h3>Starting localization process</h3>



<p>If we know the user's preferred language (in this case &quot;<code title="portuguese as spoken in Portugal">pt-PT</code>&quot;), the ECMAScript i18n API allows us to provide that information as an argument to the toLocaleDateString() function: </p>
<pre>date.toLocaleDateString(&quot;pt-PT&quot;);
//returns &quot;24/8/2012&quot;
</pre>
<p> Ok, so the above output is not super useful (it's actually less pretty than what we originally had). But it's a start on our way to localising the date more fully! However, what the above does give us is a date formatted in a way that is more or less guaranteed to be understood in the given locale, even thought it is not a pretty as having the date in &quot;long&quot; form (i.e., as in &quot;Friday, 24 of August&quot; )</p>
<p>Just so we can see the API do something more impressive, lets say our user is Chinese (language tag is &quot;za&quot;): </p>
<p>date.toLocalDateString(&quot;za&quot;)
//&quot;2012年8月24日&quot;</p>
<p>BOOM! So now we are getting somewhere! We've managed to convert our date object to Chinese without hardly doing any work (which we like!). </p>
<p>Controlling the formatting
As we pointed out above, the date format &quot;24/8/2012&quot; will be comprehended, but it's not the prettiest or most user friendly way to display dates. In particular, it's nice to see what day of the week it is (monday, tuesday, etc.) and what month. </p>
<p>However, where it gets tricky is knowing how other cultures like to have their &quot;pretty dates&quot; formatted. This is where the i18n API really starts to show its usefulness - it has this knowledge built in, and gives programmers control of how to format a date through a set of options. These options are then passed to the .toLocaleDateString() as an argument. </p>
<p>For example:
  var props = {weekday: &quot;long&quot;}; 
  date.toLocaleDateString(&quot;pt&quot;, props)
//returns &quot;sexta-feira&quot; (which is Friday in Portuguese)</p>
<p>date.toLocaleDateString(&quot;ja&quot;, props)
//&quot;金曜日&quot; which is friday in Japanse</p>
<p>weekday - &quot;narrow&quot;, &quot;short&quot;, &quot;long&quot;
  ￼era  - &quot;narrow&quot;, &quot;short&quot;, &quot;long&quot;
  year - &quot;2-digit&quot;, &quot;numeric&quot;
  month &quot;2-digit&quot;, &quot;numeric&quot;, &quot;narrow&quot;, &quot;short&quot;, &quot;long&quot;
  ￼day &quot;2-digit&quot;, &quot;numeric&quot;
  hour &quot;2-digit&quot;, &quot;numeric&quot;
  minute &quot;2-digit&quot;, &quot;numeric&quot;
  second &quot;2-digit&quot;, &quot;numeric&quot;
timeZoneName &quot;short&quot;, &quot;long&quot;</p>
<p>For example, lets say we want to output &quot;day of week, day Month, Year&quot;. We would set the following options:</p>
<p>var options = {weekday: &quot;long&quot;, year: &quot;numeric&quot;, month: &quot;long&quot;, day: &quot;numeric&quot;};
  date.toLocaleDateString(&quot;pt&quot;, props); 
//returns &quot;sexta-feira, 24 de agosto de 2012&quot;</p>
<p>date.toLocaleDateString(&quot;jp&quot;, props); 
//&quot;2012年8月24日(金曜日)&quot;</p>
<p>date.toLocaleDateString(&quot;ar&quot;, props);
//And even arabic: &quot;الجمعة، ٢٤ أغسطس، ٢٠١٢&quot;</p>
<p>//And for our final trick: Thai Buddhist calendar and Thai digits
  date.toLocaleDateString(&quot;th-u-ca-buddhist-nu-thai&quot;, props); 
//returns &quot;วันศุกร์ ๒๔ สิงหาคม ๒๕๕๕&quot;</p>
<p>Pretty funky, huh? But there is a problem... </p>
<p>Hey, Browser! You to speak-a-my-language? 
There are literally thousands of languages spoken throughout the world and those languages are spoken differently depending where you are (e.g., US English conventions are different to, say, Australian English… same with Spanish in Spain when compared to Spanish in Argentina). And even though browsers know many of these difference language/local combinations (i.e., the language tag), it can't possibly know every combination. </p>
<p>Thankfully, the i18n API provides a way to check if it knows how to deal with given locale(s). This check is done by using the somewhat long &quot;Intl.DateTimeFormat.supportedLocalesOf&quot; method: </p>
<p>//Given German (&quot;de&quot;), and two languages that don't exist: 
  Intl.DateTimeFormat.supportedLocalesOf([&quot;de&quot;, &quot;oo&quot;, &quot;xx&quot;]) 
//the browser returns [&quot;de&quot;]</p>
<p>Another cool feature of the API is that it will do it's best to support a locale as closely as it can. So, given, &quot;En-GB-fff&quot; (where fff is just something I make up), the browser will just strip away the fff and return &quot;en-GB&quot;. </p>
<p>//fff is garbage here, but could be an actual sub-tag 
  v8Intl.DateTimeFormat.supportedLocalesOf([&quot;En-gb-fff&quot;])
//returns [&quot;en-GB&quot;]</p>
<p>Note that another helpful thing that the browser does when we call &quot;supportedLocalesOf&quot; is that it normalises our languages tags into &quot;canonical form&quot; (making the GB capitalised). It will also fix errors in language tags and remove redundant tags too: </p>
<pre>
var tags = [&quot;pt-*&quot;, &quot;En-&quot;, &quot;en-*&quot;, &quot;x-foo&quot; ]; 
Intl.DateTimeFormat.supportedLocalesOf(tags);
//returns [&quot;pt&quot;, &quot;en&quot;, &quot;und-x-foo&quot;]</pre>
<p>Note above the &quot;En-&quot; and &quot;en-*&quot; become &quot;en&quot;… and note &quot;und-x-foo&quot; for private use language (language tags that a start with an &quot;x-&quot;).</p>
<p>Currencies</p>
<p>For currencies, say 12 bucks in the US is: USD$12, while its AUD$12 in Australia,  and in the UK it would be £12. We are not doing currency conversion here, just using a standardised currency code to represent how many &quot;bucks&quot; we have. </p>
<p>The list of currency codes come from a spec called <cite>ISO4217</cite>, which is published by ISO (the International Standards Organisation). ISO4217 is the authritative set of currency codes used around the world to distinguish between currencies. Each currency identified by ISO4217 is three characters long.</p>
</article>
<script src="https://raw.github.com/marcoscaceres/jsi18n/master/jsi18n_patch.js"></script>
</body>
</html>
